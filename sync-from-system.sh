#!/bin/bash
# Sync current system configs back to the dotfiles repo
# This is the reverse of install.sh - copies FROM system TO repo

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_DIR

readonly CONFIG_HOME="${HOME}/.config"

# Dry-run mode
DRY_RUN=false

# ============================================================================
# Dotfiles Configuration (keep in sync with install.sh)
# ============================================================================

# Standard config directories to sync
readonly CONFIG_DIRS=(
    "hypr"
    "mako"
    "alacritty"
    "xdg-desktop-portal"
    "rofi"
    "waybar"
    "uwsm"
)

# Home directory files (system_path:repo_path)
readonly HOME_FILES=(
    "$HOME/.vimrc:vim/vimrc"
)

# System files requiring sudo (system_path:repo_path)
readonly SYSTEM_FILES=(
    "/etc/profile.d/custom_ps1.sh:ps1/custom_ps1.sh"
)

# Files to exclude from sync (generated files, etc.)
readonly EXCLUDE_FILES=(
    "hypr/autostart.conf"  # Generated by install.sh from template
)

# Colors
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly RED='\033[0;31m'
readonly NC='\033[0m' # No Color

# ============================================================================
# Helper Functions
# ============================================================================

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

prompt_yes_no() {
    local prompt="$1"
    local default="${2:-n}"
    local answer

    if [[ "$default" == "y" ]]; then
        prompt="$prompt [Y/n]: "
    else
        prompt="$prompt [y/N]: "
    fi

    read -r -p "$prompt" answer
    answer="${answer:-$default}"

    [[ "$answer" =~ ^[Yy]$ ]]
}

is_excluded() {
    local file="$1"
    for excluded in "${EXCLUDE_FILES[@]}"; do
        if [[ "$file" == "$excluded" ]]; then
            return 0
        fi
    done
    return 1
}

show_help() {
    cat << 'EOF'
Dotfiles Sync Script (System → Repo)

USAGE:
    ./sync-from-system.sh [OPTIONS]

OPTIONS:
    -h, --help      Show this help message and exit
    -d, --dry-run   Show what would be synced without making changes

DESCRIPTION:
    Syncs configuration files from your system back to the dotfiles repo.
    This is the reverse operation of install.sh.

    Files are synced using rsync with --delete, meaning files in the repo
    that don't exist on the system will be removed (with some exceptions
    for generated files like autostart.conf).

EXAMPLES:
    ./sync-from-system.sh              Sync configs from system to repo
    ./sync-from-system.sh --dry-run    Preview what would be synced

EOF
}

# ============================================================================
# Sync Functions
# ============================================================================

sync_config_dir() {
    local name="$1"
    local source="$CONFIG_HOME/$name"
    local dest="$SCRIPT_DIR/$name"

    if [[ ! -d "$source" ]]; then
        log_warning "Config not found: $source (skipping)"
        return
    fi

    # Build exclude arguments for rsync
    local exclude_args=()
    for excluded in "${EXCLUDE_FILES[@]}"; do
        # Check if this exclusion applies to this directory
        if [[ "$excluded" == "$name/"* ]]; then
            local exclude_file="${excluded#"$name/"}"
            exclude_args+=(--exclude="$exclude_file")
        fi
    done

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}[DRY-RUN]${NC} Would sync: $source -> $dest"
        if [[ ${#exclude_args[@]} -gt 0 ]]; then
            echo -e "${YELLOW}[DRY-RUN]${NC}   Excluding: ${exclude_args[*]}"
        fi
        rsync -avn --delete "${exclude_args[@]}" "$source/" "$dest/" 2>/dev/null | head -20 || true
    else
        log_info "Syncing $name..."
        mkdir -p "$dest"
        rsync -av --delete "${exclude_args[@]}" "$source/" "$dest/"
    fi
}

sync_file() {
    local name="$1"
    local source="$2"
    local dest="$3"

    if [[ ! -f "$source" ]]; then
        log_warning "File not found: $source (skipping)"
        return
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}[DRY-RUN]${NC} Would sync: $source -> $dest"
    else
        log_info "Syncing $name..."
        mkdir -p "$(dirname "$dest")"
        cp "$source" "$dest"
    fi
}

sync_system_file() {
    local name="$1"
    local source="$2"
    local dest="$3"

    if [[ ! -f "$source" ]]; then
        log_warning "System file not found: $source (skipping)"
        return
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}[DRY-RUN]${NC} Would sync (sudo): $source -> $dest"
    else
        log_info "Syncing $name (requires sudo)..."
        mkdir -p "$(dirname "$dest")"
        sudo cp "$source" "$dest"
        sudo chown "$USER:$USER" "$dest"
    fi
}

sync_greetd_config() {
    local greetd_config="/etc/greetd/config.toml"

    if [[ ! -f "$greetd_config" ]]; then
        log_warning "greetd config not found: $greetd_config (skipping)"
        return
    fi

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}[DRY-RUN]${NC} Would sync greetd config from $greetd_config"
        return
    fi

    log_info "Syncing greetd config (requires sudo)..."

    if ! sudo -v; then
        log_error "sudo access required for greetd config"
        return 1
    fi

    mkdir -p "$SCRIPT_DIR/greetd"
    sudo cp "$greetd_config" "$SCRIPT_DIR/greetd/config.toml"
    sudo chown "$USER:$USER" "$SCRIPT_DIR/greetd/config.toml"

    log_success "greetd config synced"
}

show_changes() {
    log_info "Checking for changes..."
    echo ""

    cd "$SCRIPT_DIR" || exit 1

    if ! git diff --quiet || ! git diff --cached --quiet || [[ -n $(git ls-files --others --exclude-standard) ]]; then
        echo "Changes detected:"
        echo ""
        git status --short
        echo ""

        if prompt_yes_no "Show detailed diff?" "n"; then
            echo ""
            git diff
        fi

        return 0
    else
        log_success "No changes detected - configs are already in sync!"
        return 1
    fi
}

# ============================================================================
# Main
# ============================================================================

main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done

    # Show dry-run banner if enabled
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "${YELLOW}========================================${NC}"
        echo -e "${YELLOW}DRY-RUN MODE - No changes will be made${NC}"
        echo -e "${YELLOW}========================================${NC}"
        echo ""
    fi

    echo "=== Dotfiles Config Sync (System → Repo) ==="
    echo ""

    # Check if we're in a git repo
    if [[ ! -d "$SCRIPT_DIR/.git" ]]; then
        log_error "Not a git repository: $SCRIPT_DIR"
        exit 1
    fi

    log_info "Syncing configs from system to repo..."
    if [[ ${#EXCLUDE_FILES[@]} -gt 0 ]]; then
        log_info "Excluding generated files: ${EXCLUDE_FILES[*]}"
    fi
    echo ""

    # Sync all config directories from CONFIG_DIRS
    for dir in "${CONFIG_DIRS[@]}"; do
        sync_config_dir "$dir"
    done

    # Sync home directory files
    for file_mapping in "${HOME_FILES[@]}"; do
        local source="${file_mapping%%:*}"
        local dest="${file_mapping##*:}"
        local name
        name="$(basename "$dest")"
        sync_file "$name" "$source" "$SCRIPT_DIR/$dest"
    done

    # Sync system files (require sudo)
    local needs_sudo=false
    for file_mapping in "${SYSTEM_FILES[@]}"; do
        local source="${file_mapping%%:*}"
        if [[ -f "$source" ]]; then
            needs_sudo=true
            break
        fi
    done

    if [[ "$needs_sudo" == "true" ]]; then
        if [[ "$DRY_RUN" == "true" ]] || prompt_yes_no "Sync system files? (requires sudo)" "y"; then
            if [[ "$DRY_RUN" == "false" ]] && ! sudo -v; then
                log_error "sudo access required"
            else
                for file_mapping in "${SYSTEM_FILES[@]}"; do
                    local source="${file_mapping%%:*}"
                    local dest="${file_mapping##*:}"
                    local name
                    name="$(basename "$dest")"
                    sync_system_file "$name" "$source" "$SCRIPT_DIR/$dest"
                done
            fi
        fi
    fi

    # Sync greetd display manager config
    if [[ "$DRY_RUN" == "true" ]] || prompt_yes_no "Sync greetd config? (requires sudo)" "y"; then
        sync_greetd_config
    fi

    echo ""
    log_success "Config sync complete!"

    # Skip git operations in dry-run mode
    if [[ "$DRY_RUN" == "true" ]]; then
        echo ""
        log_info "Dry-run complete. No changes were made."
        exit 0
    fi

    echo ""

    # Show what changed
    if show_changes; then
        echo ""
        if prompt_yes_no "Commit these changes?" "y"; then
            echo ""
            read -r -p "Commit message: " commit_msg

            if [[ -n "$commit_msg" ]]; then
                git add -A
                git commit -m "$commit_msg"
                log_success "Changes committed!"

                if prompt_yes_no "Push to remote?" "y"; then
                    git push
                    log_success "Changes pushed!"
                fi
            else
                log_warning "Empty commit message - skipping commit"
            fi
        fi
    fi
}

main "$@"
